# 73. 矩阵置零_F
> 分别用一维数组来记录，而不是二维数组记录
```java
public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0){
                    row[i] = true;
                    col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]){
                    matrix[i][j] = 0;
                }
            }
        }
    }
```
# 54. 螺旋矩阵_F
>1.题目要求顺时针螺旋顺序，其实这个顺序遍历的方向是一致的，都是**右、下、左、上**以此循环，所以其实是有规律的遍历，所以可以搞一个方向数组，数组四行，每行代表一个方向，而且**遍历方向要有序**

>2.还需用一个`visited`数组，因为考虑除了遍历的时候遇到边界问题(这个可以代码判断)，还有可能遇到以前遍历过的，比如**向上遍历**的时候
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        int m = matrix.length, n = matrix[0].length;
        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        int directionIndex = 0;
        int total = m * n;
        int row = 0, col = 0;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < total; i++) {
            res.add(matrix[row][col]);
            visited[row][col] = true;
            int nextRow =  row + directions[directionIndex][0];
            int nextCol = col + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= m || nextCol < 0 || nextCol >= n || visited[nextRow][nextCol]){
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            col += directions[directionIndex][1];
        }
        return res;
    }
}

```