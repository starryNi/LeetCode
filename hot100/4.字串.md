# 560. 和为 K 的子数组_F
[前缀和](https://leetcode.cn/problems/subarray-sum-equals-k/submissions/598286983/?envType=study-plan-v2&envId=top-100-liked)
> 首先就要强调，**原做用滑动窗口来做，最后没通过，因为滑动窗口需要 序列单调**，本题并不满足这个条件

> 这道题用前缀和+哈希，**遍历右端点时，先去hash表查看 `s[right + 1] - k` 的个数，然后将右端点塞入hash表**，哈希：边用边构建(塞值)，这种做法很常见

> 理解构造前缀和的时候需要令`s[0] = 0`,因为构造完前缀和数组后，想知道left 到 right的和时候,若left == 0且没有令 `s[0] = 0`, 那么就要判断，因为left 到 right的和，并不会是`s[right] - s[left]`,这样会把`a[left]`（原数组）减掉


```java

public int subarraySum(int[] nums, int k) {
        int res = 0;
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; i++){
            s[i + 1] = s[i] + nums[i];
        }
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int sj : s){
            res += cnt.getOrDefault(sj - k, 0);
            cnt.merge(sj, 1, Integer::sum); //对键为 sj 的值进行计数，如果键 sj 不存在，则将其值初始化为 1；如果键 sj 已经存在，则将其对应的值加 1
        }
        return res;
    }
```
# 239. 滑动窗口最大值_F
[单调栈](https://www.bilibili.com/video/BV1bM411X72E/?vd_source=61f4a604a1516e0ea4f29288dea7c69a)
