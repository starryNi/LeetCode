# 53. 最大子数组和_F
> 前面出现过类似的，求连续子数组怎么样的，两个方向，如果单调，考虑滑动窗口，如果不单调，考虑前缀和

> 用前缀和的时候，考虑能不能动态构建，而不是在前面直接构建好

```java
public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int preSum = 0; //前缀和
        int minPreSum = 0; //最小前缀和
        for (int a : nums){
            // 遍历数组中元素，以这个元素为子数组的右端点，然后看怎样才能得出最小和(
            //以当前元素为子数组的右端点，这是个条件，然后看左端点选哪里是当前最小和,左端点的位置就是
            // 最小前缀和的位置)
            preSum += a;
            res = Math.max(res, preSum - minPreSum);// 减去前缀和的最小值
            minPreSum = Math.min(minPreSum, preSum);// 维护前缀和的最小值
        }
        return res;
    }
```
# 56. 合并区间_F
> 1.掌握条件排序

> 2.当数组不好操作时候(没有直接add操作)，可先在list操作，然后用toArray转成数组返回

> 思路想到了，主要是API使用
```java
public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }
        Arrays.sort(intervals, Comparator.comparingInt(value -> value[0]));
        int n = intervals.length;
        List<int[]> merged = new ArrayList<>();
        for (int[] interval : intervals) {
            int L = interval[0], R = interval[1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {
                merged.add(new int[]{L, R});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
```

